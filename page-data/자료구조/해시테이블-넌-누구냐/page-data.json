{"componentChunkName":"component---src-templates-blog-post-js","path":"/자료구조/해시테이블-넌-누구냐/","result":{"data":{"site":{"siteMetadata":{"title":"Yeongjae-Shin.io","author":"Yeongjae-Shin","siteUrl":"https://yeongjae-shin.github.io","comment":{"disqusShortName":"","utterances":"Yeongjae-Shin/Yeongjae-Shin.github.io"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"847674ac-8102-5959-9651-04ec3eaee8bc","excerpt":"해시테이블(Hash Table)이란? 해시테이블은  페어로 데이터를 저장하는 자료구조의 유형 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조 입니다.\n해시테이블이 빠른 검색속도를 제공하는 이유는 내부적으로 배열(버킷)을 이용하여 데이터를 저장하기 때문입니다. 해시테이블은 각각의 Key값에\n해시함수를 적용해 배열의 고유한 를 생성하고 이 를 활용하여 값을 저장하거나 검색하게 됩니다. 여기서 실제 값이 저장되는 장소를\n버킷 또는 슬롯이라고 합니다. 예를 들어, 우리가 가 인 데이터를 크기가 1…","html":"<h1 id=\"해시테이블hash-table이란\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94hash-table%EC%9D%B4%EB%9E%80\" aria-label=\"해시테이블hash table이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해시테이블(Hash Table)이란?</h1>\n<p>해시테이블은 <code class=\"language-text\">Key, Value</code> 페어로 데이터를 저장하는 자료구조의 유형 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조 입니다.\n해시테이블이 빠른 검색속도를 제공하는 이유는 내부적으로 배열(버킷)을 이용하여 데이터를 저장하기 때문입니다. 해시테이블은 각각의 Key값에\n해시함수를 적용해 배열의 고유한 <code class=\"language-text\">index</code>를 생성하고 이 <code class=\"language-text\">index</code>를 활용하여 값을 저장하거나 검색하게 됩니다. 여기서 실제 값이 저장되는 장소를\n버킷 또는 슬롯이라고 합니다.</p>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/7/7d/Hash_table_3_1_1_0_1_0_0_SP.svg/1200px-Hash_table_3_1_1_0_1_0_0_SP.svg.png\">\n<p>예를 들어, 우리가 <code class=\"language-text\">Key, Value</code>가 <code class=\"language-text\">'John Smith', '521-1234'</code>인 데이터를 크기가 16인 해시테이블에 저장한다고 가정해봅시다. 그러면\n면저 <code class=\"language-index = hash_function('john smith') \"> 16</code> 연산을 통해 <code class=\"language-text\">index</code>값을 계산합니다. 그리고 <code class=\"language-text\">array[index] = '521-1234'</code>로\n전화번호를 저장하게 됩니다. 이러한 구조로 데이터를 저장하면 Key값으로 데이터를 찾을 때 해시 함수를 한 번만 수행하면 되어 매우 빠르게 데이터를\n저장/삭제/조회 할 수 있습니다. </p>\n<p>이렇게 <code class=\"language-text\">index</code>를 통해 필요한 데이터를 바로 찾을 수 있기 때문에 해시테이블의 평균 시간복잡도는 <code class=\"language-text\">O(1)</code>입니다.</p>\n<h2 id=\"해시함수\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EC%8B%9C%ED%95%A8%EC%88%98\" aria-label=\"해시함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해시함수</h2>\n<p>해시함수에서 중요한 것은 고유한 인덱스 값을 설정하는 것입니다. 해시테이블에서 사용되는 대표적인 해시함수는 아래의 4가지가 있습니다. 그 중 가장 대표적인것은 <code class=\"language-text\">Division Method</code>와 <code class=\"language-text\">Multiplication Method</code>입니다.</p>\n<ol>\n<li>Division Method: 나눗셈을 이용하는 방법으로 입력값을 테이블의 크기로 나누어 계산합니다. <code class=\"language-주소 = 입력값 \"> 테이블의 크기</code>로 테이블의 크기를 소수로 정하고 2의 제곱수와 먼 값을 사용해야 효과가 좋다고 알려져 있습니다.</li>\n<li>Digit Folding: 각 Key의 문자열을 ASCII 코드로 바꾸고 값을 합한 데이터를 테이블 내의 주소로 사용하는 방법입니다.</li>\n<li>Multiplication Method: 숫자로된 Key값 K와 0과 1 사이의 실수 A, 보통 2의 제곱수인 m을 사용하여 다음과 같은 계산을 해줍니다.</li>\n<li>Universal Hashing: 다수의 해시함수를 만들어 집합 H에 넣어두고, 무작위로 해시함수를 선택해 해시값을 만드는 기법입니다.</li>\n</ol>\n<h1 id=\"해시충돌\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EC%8B%9C%EC%B6%A9%EB%8F%8C\" aria-label=\"해시충돌 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해시충돌</h1>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/5/58/Hash_table_4_1_1_0_0_1_0_LL.svg/2560px-Hash_table_4_1_1_0_0_1_0_LL.svg.png\">\n<p>해시충돌은 해시테이블의 한 주소를 놓고 두 개 이상의 원소가 충돌하는 것을 말합니다. 쉽게 말하면 해싱을 해서 삽입하려하니 이미 다른 원소가 자리를 차지하고 있는 상황을 말합니다.\n해시함수가 무한한 가짓수의 입력값을 받아 유한한 가짓수의 출력값을 생성하는 경우, <a href=\"https://ko.wikipedia.org/wiki/%EB%B9%84%EB%91%98%EA%B8%B0%EC%A7%91_%EC%9B%90%EB%A6%AC\">비둘기집 원리</a>에 의해 해시충돌은 항상 존재하게 됩니다.\n해시충돌을 해결하는 방법은 크게 2가지가 있습니다.</p>\n<h2 id=\"해시충돌-해결법\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EC%8B%9C%EC%B6%A9%EB%8F%8C-%ED%95%B4%EA%B2%B0%EB%B2%95\" aria-label=\"해시충돌 해결법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해시충돌 해결법</h2>\n<h3 id=\"분리-연결법separate-chaining\" style=\"position:relative;\"><a href=\"#%EB%B6%84%EB%A6%AC-%EC%97%B0%EA%B2%B0%EB%B2%95separate-chaining\" aria-label=\"분리 연결법separate chaining permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>분리 연결법(Separate Chaining)</h3>\n<img src=\"https://media.vlpt.us/post-images/cyranocoding/329e7e60-b226-11e9-a4ce-730fc6b3757a/16eBeaqTti8MxWPsw4xBgw.png\">\n<p>분리 연결법이란 자료를 저장할 때 버킷에서 충돌이 일어나면 해당 값을 기존 값과 연결시키는 방법입니다. 위 사진에서 Sandra를 저장할 때 충돌이 일어났고, 기존에 있던 John에 연결시켰습니다.\n이 때 연결리스트(Linked list) 자료구조를 이용합니다. 다음에 저장된 자료를 기존의 자료 다음에 위치시키는 것입니다.</p>\n<p>분리 연결법에는 장점과 단점이 존재합니다.</p>\n<h4 id=\"장점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-label=\"장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장점</h4>\n<ol>\n<li>한정된 버킷을 효율적으로 사용할 수 있습니다.</li>\n<li>해시함수를 선택하는 중요성이 상대적으로 낮습니다.</li>\n<li>상대적으로 적은 메모리를 사용합니다. 즉, 미리 공간을 잡아 놓을 필요가 없습니다.</li>\n</ol>\n<h4 id=\"단점\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-label=\"단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단점</h4>\n<ol>\n<li>데이터의 수가 많아지면 동일한 버킷에 연결되는 데이터가 많아지게 됩니다. (쏠림 현상)</li>\n<li>그에 따라 캐싱의 효율성이 감소하게 됩니다.</li>\n<li>추가 저장 공간을 사용해야 합니다.</li>\n</ol>\n<h3 id=\"개방-주소법open-addressing\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EB%B0%A9-%EC%A3%BC%EC%86%8C%EB%B2%95open-addressing\" aria-label=\"개방 주소법open addressing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개방 주소법(Open Addressing)</h3>\n<p>개방 주소법이란 추가적인 메모리를 사용하는 분리 연결법 방식과 다르게 비어있는 해시 테이블의 공간을 활용하는 방법입니다. 개방 주소법을 구현하기 위한 방식에는 대표적으로 3가지가 있습니다.</p>\n<ol>\n<li>Linear Probing: 현재 버킷의 <code class=\"language-text\">index</code>로부터 고정폭만큼 이동하여 차례대로 검색해 비어 있는 버킷에 데이터를 저장하는 방식입니다.</li>\n<li>Quadratic Probing: 해시의 저장순서 폭을 제곱으로 저장하는 방식입니다. 예를 들어, 처음 충돌이 발생한 경우에는 1만큼 이동하고 그 다음 계속 충돌이 발생하면 2^2, 3^2칸씩 옮기는 방식입니다.</li>\n<li>Double Hashing Probing: 해시된 값을 한 번 더 해싱하여 해시의 규칙성을 없애버리는 방식입니다. 한 번 더 해싱하여 새로운 주소를 할당하기 때문에 다른 방법들보다 많은 연산을 하게 됩니다.</li>\n</ol>\n<img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FWR1fv%2FbtqL5APCcSa%2FBZN6wvxUXzJBEiOfOMLfR0%2Fimg.png\">\n<h4 id=\"장점-1\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EC%A0%90-1\" aria-label=\"장점 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장점</h4>\n<ol>\n<li>또 다른 저장공간 없이 해시테이블 내에서 데이터 저장 및 처리가 가능합니다.</li>\n<li>또 다른 저장공간에서의 추가적인 작업이 없습니다.</li>\n</ol>\n<h4 id=\"단점-1\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90-1\" aria-label=\"단점 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단점</h4>\n<ol>\n<li>해시함수의 성능에 전체 해시테이블의 성능이 좌지우지 됩니다.</li>\n<li>데이터의 길이가 늘어나면 그에 해당하는 저장소를 마련해두어야 합니다.</li>\n</ol>\n<h1 id=\"해시테이블의-시간-복잡도\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%98-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"해시테이블의 시간 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해시테이블의 시간 복잡도</h1>\n<p>각각의 Key값은 해시함수에 의해 고유한 <code class=\"language-text\">index</code>를 가지게 되어 바로 접근할 수 있으므로 평균 O(1)의 시간복잡도로 데이터를 조회할 수 있습니다.\n하지만 해시충돌이 발생한 경우 체이닝에 연결된 리스트들까지 검색을 해야하기 때문에 최악의 경우 O(n)까지 시간복잡도가 증가할 수 있습니다.\n만약 테이블이 꽉 차있는 경우라면 테이블을 확장해야 하는데, 이는 매우 섬각한 성능의 저하를 불러오기 때문에 가급적이면 확장을 하지 않도록 테이블을 설계해야 합니다.\n해시테이블의 공간 사용률이 70 ~ 80% 정도가 되면 해시충돌이 빈번하게 발생하여 성능이 저하되기 시작한다고 합니다.</p>\n<p>또한 해시테이블에서 자주 사용하게 되는 데이터를 캐시에 적용하면 효율을 높일 수 있습니다. 자주 hit하게 되는 데이터를 캐시에서 바로 찾음으로써 해시테이블의 성능을 향상시킬 수 있습니다.</p>","frontmatter":{"title":"해시테이블 넌 누구냐","date":"November 14, 2021"}}},"pageContext":{"slug":"/자료구조/해시테이블-넌-누구냐/","previous":{"fields":{"slug":"/JavaScript/실행-컨텍스트-그리고-이벤트루프/"},"frontmatter":{"title":"실행 컨텍스트 그리고 이벤트루프"}},"next":null}},"staticQueryHashes":["2486386679","3128451518"]}